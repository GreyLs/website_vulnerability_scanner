import requests
from bs4 import BeautifulSoup
import logging
import ssl
from urllib.parse import urlparse

# настройка логирования
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

# константы
SECURITY_HEADERS = [
    'Content-Security-Policy',
    'X-Frame-Options',
    'X-Content-Type-Options',
    'Strict-Transport-Security',
    'X-XSS-Protection',
]

# функции

def check_security_headers(response):
    """Проверяет наличие заголовков безопасности в ответе сервера."""
    headers = response.headers
    return [header for header in SECURITY_HEADERS if header not in headers]

def check_ssl_certificate(target_url):
    """Проверяет SSL сертификат веб-сайта."""
    parsed_url = urlparse(target_url)
    hostname = parsed_url.hostname
    port = parsed_url.port or 443
    context = ssl.create_default_context()
    try:
        with context.wrap_socket(ssl.socket(), server_hostname=hostname) as s:
            s.connect((hostname, port))
            cert = s.getpeercert()
            ssl.match_hostname(cert, hostname)
            logging.info(f"SSL сертификат для {hostname} действителен.")
            return True
    except ssl.CertificateError as e:
        logging.error(f"Недействительный SSL сертификат для {hostname}: {e}")
    except ssl.SSLError as e:
        logging.error(f"Проблемы с SSL сертификатом для {hostname}: {e}")
    except Exception as e:
        logging.error(f"Ошибка при проверке SSL сертификата для {hostname}: {e}")
    return False

def check_csrf(response):
    """Проверяет на уязвимость CSRF."""
    soup = BeautifulSoup(response.text, 'html.parser')
    forms = soup.find_all('form')
    for form in forms:
        if form.get('method', '').upper() != 'GET':
            csrf_token = form.get('csrf-token')
            if not csrf_token:
                csrf_token_input = form.find('input', attrs={'name': 'csrf_token'})
                if not csrf_token_input:
                    return False, f"Возможная уязвимость CSRF в форме: {form.get('action')}"
    return True, None

def scan_website(target_url):
    """Сканирует веб-сайт на наличие уязвимостей."""
    vulnerabilities = []

    # проверка SSL сертификата
    if not check_ssl_certificate(target_url):
        vulnerabilities.append(f"Проблемы с SSL сертификатом для {target_url}")

    # скачивание HTML-кода веб-страницы и проверка заголовков безопасности
    try:
        response = requests.get(target_url, verify=True)
        response.raise_for_status()
        missing_headers = check_security_headers(response)
        if missing_headers:
            vulnerabilities.append(f"Отсутствуют заголовки безопасности: {missing_headers}")

        # проверка CSRF
        csrf_status, csrf_message = check_csrf(response)
        if not csrf_status:
            vulnerabilities.append(csrf_message)

    except requests.exceptions.SSLError as e:
        vulnerabilities.append(f"Проблемы с SSL сертификатом: {e}")
    except requests.exceptions.RequestException as e:
        logging.error(f"Ошибка при получении страницы: {e}")
        return vulnerabilities

    return vulnerabilities

# точка входа в программу
if __name__ == "__main__":
    target_url = input("Введите URL веб-сайта для сканирования: ")
    vulnerabilities = scan_website(target_url)
    if vulnerabilities:
        logging.warning(f"Найдены уязвимости: {vulnerabilities}")
    else:
        logging.info("Уязвимости не найдены.")
